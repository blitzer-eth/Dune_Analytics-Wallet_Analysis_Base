-- Seaport 1.6 â€” Wallet-level net cashflow on Base (ETH-only; handles partial refunds)
-- Params: {{Start Date:}} (YYYY-MM-DD), {{End Date:}} (YYYY-MM-DD), {{wallet address:}} (0x...)
-- Outputs: per-NFT row gross/net ETH, daily & cumulative P/L (ETH)

WITH
params AS (
  SELECT
    CAST(
      COALESCE(
        NULLIF('{{Start Date:}}', 'YYYY-MM-DD'),
        CAST((CURRENT_DATE - INTERVAL '30' DAY) AS VARCHAR)
      ) AS TIMESTAMP
    ) AS start_date,
    CAST(
      COALESCE(
        NULLIF('{{End Date:}}', 'YYYY-MM-DD'),
        CAST(CURRENT_DATE AS VARCHAR)
      ) AS TIMESTAMP
    ) AS end_date
),
address AS (
  SELECT FROM_HEX(REPLACE('{{wallet address:}}', '0x', '')) AS addr
),
const AS (
  SELECT
    FROM_HEX('0000000000000068f116a894984e2db1123eb395') AS seaport   -- Seaport 1.6 on Base
),

-- -----------------------------------------------
-- Seaport 1.6 transactions on Base (time bounded)
-- -----------------------------------------------
seaport_tx AS (
  SELECT DISTINCT l.tx_hash
  FROM base.logs l
  CROSS JOIN params
  CROSS JOIN const
  WHERE l.contract_address = const.seaport
    AND l.block_time BETWEEN params.start_date AND params.end_date
),

-- -----------------------------
-- 1) NFT transfers (Base; Seaport-only txs touching our wallet)
-- -----------------------------
nft_raw AS (
  SELECT
      e.evt_block_time                          AS time,
      e.evt_tx_hash                             AS tx_hash,
      e.evt_tx_index                            AS evt_index,
      e."from",
      e."to",
      e.contract_address,
      CAST(e.tokenId AS VARCHAR)                AS token_id,
      CAST(1 AS BIGINT)                         AS qty,
      'ERC721'                                  AS standard
  FROM erc721_base.evt_Transfer e
  INNER JOIN seaport_tx s ON s.tx_hash = e.evt_tx_hash
  CROSS JOIN address
  CROSS JOIN params
  WHERE (e."from" = addr OR e."to" = addr)
    AND e.evt_block_time BETWEEN params.start_date AND params.end_date

  UNION ALL

  SELECT
      s5.evt_block_time,
      s5.evt_tx_hash,
      s5.evt_tx_index,
      s5."from",
      s5."to",
      s5.contract_address,
      CAST(s5.id AS VARCHAR),
      CAST(s5.value AS BIGINT)                  AS qty,
      'ERC1155'
  FROM erc1155_base.evt_TransferSingle s5
  INNER JOIN seaport_tx s ON s.tx_hash = s5.evt_tx_hash
  CROSS JOIN address
  CROSS JOIN params
  WHERE (s5."from" = addr OR s5."to" = addr)
    AND s5.evt_block_time BETWEEN params.start_date AND params.end_date
),
nft_transfers AS (
  SELECT
      *,
      DATE_TRUNC('day', time) AS day
  FROM nft_raw
),

-- -----------------------------
-- 2) Wallet <-> Seaport ETH net per tx (captures partial-fill refunds)
-- -----------------------------
eth_wallet_seaport AS (
  SELECT
    t.tx_hash,
    SUM(
      CASE
        WHEN t."from" = addr AND t."to" = const.seaport
          THEN - t.value / 1e18            -- ETH sent to Seaport (spend)
        WHEN t."from" = const.seaport AND t."to" = addr
          THEN   t.value / 1e18            -- ETH refunded from Seaport (refund)
        ELSE 0
      END
    ) AS tx_net_eth
  FROM base.traces t
  INNER JOIN seaport_tx s ON s.tx_hash = t.tx_hash
  CROSS JOIN address
  CROSS JOIN const
  CROSS JOIN params
  WHERE t.value > 0
    AND t.call_type = 'call'
    AND t.block_time BETWEEN params.start_date AND params.end_date
    AND (
          (t."from" = addr AND t."to"   = const.seaport) OR
          (t."from" = const.seaport AND t."to" = addr)
        )
  GROUP BY 1
),

-- -----------------------------
-- 3) Classify rows & allocate tx_net_eth across NFT rows (by qty; BUY negative)
-- -----------------------------
classified AS (
  SELECT
    n.time,
    n.day,
    n.tx_hash,
    n.standard,
    n.qty,
    CASE WHEN n."from" = addr THEN 'SELL'
         WHEN n."to"   = addr THEN 'BUY'
         ELSE 'RELATED' END AS direction,
    -- allocation weight by qty (fallback to even split)
    CASE
      WHEN SUM(n.qty) OVER (PARTITION BY n.tx_hash) > 0
        THEN n.qty * 1.0 / SUM(n.qty) OVER (PARTITION BY n.tx_hash)
      ELSE 1.0 / COUNT(*) OVER (PARTITION BY n.tx_hash)
    END AS alloc_w,
    n.contract_address,
    n.token_id,
    CASE WHEN n."from" = addr THEN n."to" ELSE n."from" END AS counterparty,
    tp.tx_net_eth
  FROM nft_transfers n
  LEFT JOIN eth_wallet_seaport tp ON tp.tx_hash = n.tx_hash
  CROSS JOIN address
),

-- -----------------------------
-- 4) Gas: charge only if WE are the sender; allocate by same weights
-- -----------------------------
tx_gas AS (
  SELECT
    t.hash AS tx_hash,
    (t.gas_used * t.gas_price) / 1e18 AS gas_eth
  FROM base.transactions t
  INNER JOIN seaport_tx s ON s.tx_hash = t.hash
  CROSS JOIN address
  CROSS JOIN params
  WHERE t."from" = addr
    AND t.block_time BETWEEN params.start_date AND params.end_date
),
classified_net AS (
  SELECT
    c.time, c.day, c.tx_hash, c.standard, c.qty, c.direction,
    -- Signed cash per row: tx_net_eth * alloc_w (SELL +, BUY -)
    (CASE WHEN c.direction = 'SELL' THEN  1
          WHEN c.direction = 'BUY'  THEN  1
          ELSE 0 END) * COALESCE(c.tx_net_eth, 0) * c.alloc_w
      AS gross_eth_value,
    COALESCE(g.gas_eth, 0) * c.alloc_w AS gas_eth_allocated,
    ( (CASE WHEN c.direction = 'SELL' THEN  1
            WHEN c.direction = 'BUY'  THEN  1
            ELSE 0 END) * COALESCE(c.tx_net_eth, 0) * c.alloc_w )
      - COALESCE(g.gas_eth, 0) * c.alloc_w
      AS net_eth_value,
    c.contract_address, c.token_id, c.counterparty
  FROM classified c
  LEFT JOIN tx_gas g ON g.tx_hash = c.tx_hash
),

-- -----------------------------
-- 5) Daily summaries on NET cash flow
-- -----------------------------
netflow_summary AS (
  SELECT
    day,
    SUM(net_eth_value) AS daily_profit_loss,
    SUM(SUM(net_eth_value)) OVER (ORDER BY day) AS cumulative_profit_loss
  FROM classified_net
  GROUP BY day
),

-- -----------------------------
-- 6) Final view (per transfer + daily rollups)
-- -----------------------------
final_output AS (
  SELECT
    'TRADE' AS view_type,
    c.time,
    c.day,
    c.tx_hash,
    c.standard,
    c.qty,
    c.direction,
    c.gross_eth_value,
    c.gas_eth_allocated,
    c.net_eth_value,
    CASE WHEN c.qty > 0 THEN c.gross_eth_value / c.qty END AS gross_eth_per_unit,
    CASE WHEN c.qty > 0 THEN c.net_eth_value   / c.qty END AS net_eth_per_unit,
    c.contract_address,
    c.token_id,
    c.counterparty,
    n.daily_profit_loss,
    n.cumulative_profit_loss
  FROM classified_net c
  LEFT JOIN netflow_summary n
    ON c.day = n.day
  ORDER BY c.time DESC
)

SELECT * FROM final_output;
